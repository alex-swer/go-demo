# Указатели и указатели на указатель в Go

## Обычные указатели

- `*T` — указатель на тип T
- `&a` — получить адрес переменной a
- `*p` — получить значение по адресу p

**Пример:**
```go
a := 10
p := &a      // p is a pointer to a
fmt.Println(*p) // 10
*p = 20      // change the value at the address p
fmt.Println(a) // 20
```

## Указатель на указатель

- `**T` — указатель на указатель на тип T
- Используется, когда нужно изменить сам указатель внутри функции

**Пример:**
```go
func setToNil(p **int) {
    *p = nil // change the pointer itself, to which p points
}

func main() {
    a := 10
    ptr := &a
    fmt.Println(ptr) // address of a

    setToNil(&ptr)
    fmt.Println(ptr) // now ptr == nil
}
```

## Когда это нужно
- Когда нужно изменить сам указатель, а не только значение по адресу
- При работе с динамическими структурами (например, изменять head у связного списка)

---

## Работа с unsafe.Pointer и низкоуровневым доступом к памяти

### Приведение указателей

```go
bytePointer := (*uint8)(pointer)
```
- `pointer` — это переменная типа `unsafe.Pointer` (универсальный указатель).
- `(*uint8)(pointer)` — приведение типа: мы говорим компилятору, что по этому адресу лежит значение типа `uint8` (1 байт).
- Теперь `bytePointer` — это указатель на 1 байт по адресу, на который указывает `pointer`.

### Почему *bytePointer читает только 1 байт?
- Тип указателя определяет, сколько байт будет прочитано при разыменовании (`*`).
- `*uint8` — читает 1 байт (8 бит).
- Даже если по этому адресу лежит больше данных (например, 4 байта для uint32), Go считает, что мы хотим только 1 байт.
- Это позволяет читать отдельные байты из многобайтовых переменных.

### Смещение указателя

```go
pointer = unsafe.Add(pointer, 2)
twoBytePointer := (*uint16)(pointer)
```
- `unsafe.Add(pointer, 2)` — сдвигает указатель на 2 байта вперёд (например, чтобы читать не с начала переменной, а с третьего байта).
- `(*uint16)(pointer)` — теперь это указатель на 2-байтовое значение (uint16) по новому адресу.

### Зачем это делать?
- Иногда нужно читать/писать отдельные байты или слова внутри структуры или массива байт (например, при работе с бинарными протоколами, парсинге файлов, оптимизациях).
- Это позволяет обращаться к памяти напрямую, как в C/C++.
- Например, если у тебя есть большой массив байт, и ты знаешь, что по определённому смещению лежит 2-байтовое число — ты можешь получить его так, не копируя данные.

### Важно!
- Использование `unsafe` — это мощный, но опасный инструмент. Можно легко получить некорректные данные или ошибку.
- Обычно такие трюки нужны только для низкоуровневых задач, драйверов, парсеров бинарных форматов, или для оптимизации.

---

Если нужно разобрать конкретный кейс — пиши!

Если нужно больше примеров — пиши!
